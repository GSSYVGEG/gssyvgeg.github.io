[TOC]



# vue

## vue cli项目创建

### 创建新的基础项目

1. pc中安装Node.js（8.9以上版本），其中包含了npm工具。

2. ```
   npm install -g @vue/cli
   ```

3. 开始创建新项目。

   ```
   vue create hello-world //项目名称
   ```

   选择默认的preset。

### 添加各种插件依赖

#### 添加axios

```
npm install axios
npm install vue-axios
```

```javascript
import axios from 'axios'
import VueAxios from 'vue-axios'

Vue.use(VueAxios，axios);
```



#### 添加router

```
vue add router
```

#### 跨域访问配置

+ 更改访问端口

+ 解决跨域资源访问问题。设置代理

  ```javascript
  //vue项目根目录下创建vue.config.js文件
  module.exports = {
      devServer: {
          open: process.platform === 'darwin',
          host: '127.0.0.1',
          port: 8082,
          https: false,
          hotOnly: false,
          proxy: {
              '/api':{
                  target:'http://localhost:8080/',
                  changeOrigin: true,
                  pathRewrite:{
                      '^/api':''
                  }
              }
          },
          before: app => {}
      },
  };
  ```

  

## vue cli 项目部署

### 部署到springboot项目

+ npm run build。运行后获得dist目录。
+ 将dist下所有文件部署到后端静态资源文件夹下。

+ springboot适配Vue项目history路由模式。

  参考：<https://www.jianshu.com/p/5b24ae4cc159>

  主要原理：springboot匹配不到url时，默认会返回404页面。通过修改默认配置Bean，当匹配不到时，返回index.html页面。

  ~~~java
  import org.springframework.boot.web.server.ConfigurableWebServerFactory;
  import org.springframework.boot.web.server.ErrorPage;
  import org.springframework.boot.web.server.WebServerFactoryCustomizer;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  import org.springframework.http.HttpStatus;
  
  @Configuration
  public class ServletConfig {
      /**
       * 适配vue项目的history路由模式
       * SpringBoot2.0以上版本WebServerFactoryCustomizer代替之前版本的EmbeddedWebServerFactoryCustomizerAutoConfiguration
       * @return
       */
      @Bean
      public WebServerFactoryCustomizer<ConfigurableWebServerFactory> webServerFactoryCustomizer() {
          return new WebServerFactoryCustomizer<ConfigurableWebServerFactory>() {
              @Override
              public void customize(ConfigurableWebServerFactory factory) {
                  ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/index.html");
                  factory.addErrorPages(errorPage404);
              }
          };
      }
  }
  ~~~

  



## vue cli定义全局变量

### 应用一、配置文件

+ 在main.js中，Vue.prototype.xxx = xxx。即可通过{{xxx}}的形式使用该变量。
+ 全局变量通常是作为配置参数，故可以统一写在config.js文件中，在mian.js中引入即可。
+ 详细信息查看<https://blog.csdn.net/just_for_your_smile/article/details/78815783>。vue-cli全局变量 - just_for_your_smile的专栏 - CSDN博客

```javascript
//config.js
export default{
    install(Vue,options){
        Vue.prototype.baseUrl = {
            html:'http://localhost:8082',
            axios:  'http://localhost:8082/api/itb',
        };
    }
}
//调用
//1、js代码中
this.baseUrl.html
//2、html代码中
baseUrl.html
```



### 应用二、可在组件间共享的全局数据

+ 把重复利用率高的数据抽取出来，达到方便组件间数据共享的目的。
+ 其实就是Vue文档里的**简单状态管理**，store模式。
+ 进一步优化并丰富功能之后，就成了vuex。
+ 参考：[https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8](https://cn.vuejs.org/v2/guide/state-management.html#简单状态管理起步使用)

## vue cli  生产环境与开发环境

参考：<http://liguixing.com/archives/1044>

+ 基本原理

  使用条件判断 **process.env.NODE_ENV**的值，以得知当前所处的环境是开放环境还是生产环境，从而再做不同的处理。

  ~~~ javascript
  if (process.env.NODE_ENV === 'production') {
              Vue.prototype.baseUrl = {
                  //生产环境
                  html:'http://localhost:8080/#',
                  axios:  'http://localhost:8080/itb',
              };
          }else {
              Vue.prototype.baseUrl = {
                  html:'http://localhost:8082/#',
                  axios:  'http://localhost:8082/api/itb',
              };
          }
  ~~~

  

## 使用子组件

```javascript
	//1.导入组件文件
	import Header from '../components/Header'
    export default {
        name: "Home",
        data(){
            return{
                
            }
        },
        //2.注册组件
        components:{
            'Header':Header
        },
    }
```

```html
//3.使用组件
<Header></Header>
```



## 监听vue子组件的props值

```javascript
export default{
   props:['dataId'], 
   watch:{
      dataId:{
        immediate:true,
        handler(val){
          this.getVideoById(val);
        }
      }
    },
}
```

## 小细节

### 变量的深拷贝

```javascript
$_adminVideo_put:function (video) {
     //深拷贝
    this.inputVideo = JSON.parse(JSON.stringify(video));
    
    this.editEnable = true;
    this.putBtn = true;
},
```

***

# ITB项目

## 客户端发起put请求，数据含多个大文件

+ 如下图所示，当更新请求的数据中包含大文件

![1565852186876](C:\a\cf\文档\itb项目记录\imgs\1565852186876.png)



+ 选择文件后，上传动作立即开始，上传后弹出alert提示成功与否。
+ 服务器后端将得到的文件后的处理
  1. 检查文件md5值，判断文件在服务器中是否已存在。
  2. 固定存放在服务器，c:/itbTemp/{id}/xxx.xx
  3. 存放后，在数据库中生成一条记录，内容包括id、文件名、文件类型、md5值等信息。
+ 点击提交修改按钮后，除文件外的其他参数提交给服务器。此次服务器收到更新请求后，生成CDN链接，并与其他参数合并成完整object对象，再存进数据库。

## 关于大文件上传的实现

+ ~~一个完善方案（放弃）~~

​	了解到的完善的实现方案是：plupload + element ui + vue + spring boot。

具体：使用plupload作为文件上传的js库

该方案能够实现分块上传，断点续传，秒传等丰富的功能。

放弃原因：该方案会导致后端controller由于plupload的接口情况，而受到限制。违反了以后端为中心的项目编写原则。

+ 自定义方案

​	前端只上传文件和文件对应的item的id。所有秒传，md5值计算等都在后端进行实现。

​	修正：秒传功能必须由前端计算好md5值后，发送md5给后端进行处理。因为在后端能计算md5时，整个文件已经上传到了服务器中。

## 英语词典项目





***

# spring

## spring cloud

### 项目练习

#### 环境说明

+ spring-cloud-dependencies版本：Greenwich.SR3

+ spring-boot-dependencies版本：2.1.6.RELEASE

  

#### 组成工具

+ eureka：用于服务的注册和发现

  + 各个微服务作为实例向eureka服务器注册。

    ![1571566152460](imgs\1571566152460.png)

  + 注册完成后，实例会归属到某个应用中。

    ![1571566048140](imgs\1571566048140.png)

  + 一个应用可以拥有多个实例。

    ![1571565844932](imgs\1571565844932.png)

+ ribbon：客户端的负载均衡（软件/进程 层面）

  + 默认采用轮询的方式

    ```java
    /**
     * 改变ribbon负载均衡的选取算法
     * @return
     */
    @Bean
    public IRule getRule(){
        //ribbon默认情况下选用RoundRobinRule，轮询算法：按顺序选取。
        //可自定义。实现IRule后，在此方法内返回即可
        return new RoundRobinRule();
    }
    ```

+ hystrix：熔断器，微服务异常处理

  + @EnableCircuitBreaker作用在微服务实例上。

  服务熔断：通过在A方法上注解@HystrixCommand(fallbackMethod = "xxx")，当provider的抛出异常时，会跳到名为xxx的方法里处理，xxx方法会返回给消费者错误信息以结束请求过程，达到熔断的目的，防止A方法内由于某错误原因 而迟迟不返回结果。

  服务降级：消费者应该设置fallbackFactory，当微服务实例熔断后，消费者返回错误信息。

  

+ hystrix-dashboard：监控微服务实例的访问情况。

+ zuul：网关和路由。通过访问zuul服务器来访问内部的微服务群。

  内嵌了ribbon 和 hystrix

+ spring cloud config：配置中心，用于集中管理配置文件。其实与spring cloud并没有什么关联。

  分为服务端和客户端两部分。

  ```xml
  客户端依赖
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-config</artifactId>
  </dependency>
  服务端依赖
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-config-server</artifactId>
  </dependency>
  ```

  

#### 流程

##### 父工程sprin-cloud-itb-demo

pom文件

```xml
<modules>
    <module>itb-demo-api</module>
    <module>itb-demo-video-provider</module>
    <module>itb-demo-video-consumer</module>
</modules>

<groupId>net.f3322.gssyvgeg</groupId>
<artifactId>spring-cloud-itb-demo</artifactId>
<packaging>pom</packaging>
<version>1.0-SNAPSHOT</version>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.1.6.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>Greenwich.SR3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

```

##### 服务提供者itb-demo-video-provider

+ pom文件

  ```xml
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
  </dependency>
  ```

+ 在springboot启动类上添加**@EnableDiscoveryClient**注解。在使用eureka的情况下，也可以使用**@EnableEurekaClient**注解，两者在此情况下效果一样。

  spring cloud中discovery service有许多种实现（eureka、consul、zookeeper等等），@EnableDiscoveryClient基于spring-cloud-commons, @EnableEurekaClient基于spring-cloud-netflix。

+ 配置application.yml

  ```yaml
  eureka:
    client:
      service-url:
        defaultZone: http://127.0.0.1:7001/eureka/
    instance:
      #instance-id: microservicecloud-video8001      # 修改微服务名称
      prefer-ip-address: true                      # 设置ip地址访问
  
  spring:
    application:
      name: cloud-video
  ```


+ 加入hystrix和hystrix-dashboard

  + 

    ```xml
    <!--实例监控-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
    </dependency>
    ```

  + 配置application.yml

  ```yaml
  management:
    endpoints:
      web:
        exposure:
          include: hystrix.stream
  ```

  + 在springboot启动类上添加@EnableCircuitBreaker

  + 在需要熔断处理的方法上添加@HystrixCommand(fallbackMethod = "xxx")，并创建名为xxx的方法，作为错误后的的响应处理。

    ```java
    @GetMapping("/{id}")
    @HystrixCommand(fallbackMethod = "handleGetVideoById")
    public VideoDto getVideoById(@PathVariable Integer id){
        VideoDto result = videoService.queryById(id);
        if (result == null){
            throw new RuntimeException("ID:" +  id + "  查无信息。");
        }
        return result;
    }
    public VideoDto handleGetVideoById(@PathVariable Integer id){
        VideoDto videoDto = new VideoDto();
        videoDto.setId(id);
        videoDto.setName("ID:" + id+ "  查无信息。");
        return videoDto;
    }
    ```

  + 访问http://【hystrix-dashboard-app】:【port】/hystrix

    ![1571666966442](imgs\1571666966442.png)

  + 输入http://【provider-app】:【port】/actuator/hystrix.stream，设定ping间隔时间，起个标题。如上图。

    ![1571667172778](imgs\1571667172778.png)

+ 使用spring cloud config客户端

  + 依赖

    ```xml
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-config</artifactId>
    </dependency>
    ```

  + 新建bootstrap.yml配置文件。

    该配置文件的优先级比application高。

    ```yaml
    spring:
      cloud:
        config:
          uri: http://localhost:7004  #spring cloud config服务器的uri
          name: video-provider-application	#文件名称，这里表示获取名为video-provider-application-xxx的配置文件内的信息，xxx为环境标识
          label: master
          profile: dev	#环境标识
    ```

  + 此时可以删除原来的application.yml文件。到此为止，相当于把原先application.yml里的配置信息改成了video-provider-application-xxx.yml中的信息。video-provider-application-xxx.yml即为存放在github仓库中的文件。

##### 创建spring cloud config服务器itb-demo-cloud-config

+ pom

  ```xml
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-config-server</artifactId>
  </dependency>
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
  </dependency>
  ```

+ 配置为eureka客户端，并注册进euraka服务器。

+ 启动类上添加注解 **@EnableConfigServer**

  ```java
  @SpringBootApplication
  @EnableConfigServer
  @EnableDiscoveryClient
  public class CloudConfigApp {
      public static void main(String[] args) {
          SpringApplication.run(CloudConfigApp.class, args);
      }
  }
  ```

+ 配置application.yml

  spring cloud config 支持读取多种配置文件存放方式，这里演示github方式。

  ```yaml
  spring:
    application:
      name: cloud-config-server
    cloud:
      config:
        label: master
        server:
          git:
            uri: https://github.com/GSSYVGEG/cloud-config-itb-demo	#读取的是github上cloud-config-itb-demo仓库中的文件
            username: ******  #github账号密码
            password: ******
  
  
  eureka:
    client:
      service-url:
        defaultZone: http://127.0.0.1:7001/eureka/
    instance:
      instance-id: cloud-config-server-7004      # 修改微服务名称
      prefer-ip-address: true                      # 设置ip地址访问
  
  server:
    port: 7004
  ```

+ 在github上创建名为cloud-config-itb-demo的仓库。

  在仓库中创建video-provider-application-dev.yml文件。内容如下：

  ```yaml
  server:
    port: 8001
  
  eureka:
    client:
      service-url:
        defaultZone: http://127.0.0.1:7001/eureka/
    instance:
      instance-id: video-provider-8001      # 修改微服务名称
      prefer-ip-address: true                      # 设置ip地址访问
  
  
  spring:
    application:
      name: cloud-video
    datasource:
      username: root
      password: ******	#数据库密码
      url: jdbc:mariadb://gssyvgeg.f3322.net:53307/xing
      driver-class-name: org.mariadb.jdbc.Driver
      type: com.alibaba.druid.pool.DruidDataSource
      #   数据源其他配置
      initialSize: 5
      minIdle: 5
      maxActive: 20
      maxWait: 60000
      timeBetweenEvictionRunsMillis: 60000
      minEvictableIdleTimeMillis: 300000
      validationQuery: SELECT 1 FROM DUAL
      testWhileIdle: true
      testOnBorrow: false
      testOnReturn: false
      poolPreparedStatements: true
      #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
      filters: stat,wall
      maxPoolPreparedStatementPerConnectionSize: 20
      useGlobalDataSourceStat: true
      connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
  
  logging:
    level.root: info
  
  mybatis:
    config-location: classpath:mybatis-config.xml
    mapper-locations: classpath:mapper/*.xml
  
  pagehelper:
    #helperDialect: mariadb
    reasonable: true
    supportMethodsArguments: true
  
  management:
    endpoints:
      web:
        exposure:
          include: hystrix.stream
  ```

  以上yaml文件内容其实是itb-demo-video-provider模块中的application.yml文件的内容。放在这里以供后续的spring cloud config 客户端来读取。

##### 创建eureka服务端itb-demo-eureka-server

+ pom文件

```xml
<dependencies>
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
	</dependency>
</dependencies>
```

+ 创建一个普通的springboot应用

+ 在启动类VideoProviderApp上添加**@EnableEurekaServer**注解。

+ 配置application.yml

  ```yaml
  server:
    port: 7001
  eureka:
    instance:
      hostname: eureka7001    # eureka 服务器端的实例名称
    client:
      register-with-eureka: false  # false 标识不向注册公司注册自己
      fetch-registry: false  # false 标识自己是注册中心
      service-url:
          defaultZone: http://127.0.0.1:7001/eureka/  # 设置与eureka server交互的地址查询服务和注册服务
  ```

##### 消费者itb-demo-video-consumer

使用ribbon+RestTemplate，实现访问itb-demo-video-provider时负载均衡。

+ 把项目配置成一个普通的微服务客户端，大致过程：

  + spring-cloud-starter-netflix-eureka-client依赖

  + springboot启动类上添加**@EnableEurekaClient**注解

  + 配置application.yml

    ```yaml
    spring:
      application:
        name: cloud-consumer-video
    
    eureka:
      client:
        service-url:
          defaultZone: http://127.0.0.1:7001/eureka/
        #register-with-eureka: false
      instance:
    #    instance-id: cloud-video      # 修改微服务名称
        prefer-ip-address: true                # 设置ip地址访问
    ```

+ 声明一个RestTemplate的bean

  ```java
  @Configuration
  public class BeanConfig {
      @Bean
      public RestTemplate getTemplate(){
          return new RestTemplate();
      }
  }
  ```

+ 创建controller类，使用RestTemplate向provider发送请求，以此作为方法实现

  ```java
  @RestController
  @RequestMapping("/api/video")
  public class VideoRestController {
      
      private static final String REST_URL_PREFIX = "http://127.0.0.1:8001";
      @Autowired
      private RestTemplate restTemplate;
  
      @GetMapping
      public List<VideoDto> query(){
          return restTemplate.getForObject(REST_URL_PREFIX+"/itb/video", List.class);
      }
  ```

+ 使用ribbon

  + pom

    ```xml
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
    </dependency>
    ```

  + 在RestTemplate的bean上添加**@LoadBalanced**注解

    ```java
    @Bean
    @LoadBalanced
    public RestTemplate getTemplate(){
        return new RestTemplate();
    }
    ```

  + 在springboot启动类上添加**@EnableEurekaClient**注解

##### zuul服务器itb-demo-zuul

+ porn

  ```xml
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
  </dependency>
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
  </dependency>
  ```

+ 作为eureka客户端注册进eureka

  ```yaml
  server:
    port: 7003
  
  spring:
    application:
      name: zuul-server
  
  eureka:
    client:
      service-url:
        defaultZone: http://127.0.0.1:7001/eureka/
    instance:
      #instance-id: microservicecloud-video8001      # 修改微服务名称
      prefer-ip-address: true
  ```

  ```java
  @EnableZuulProxy
  @SpringBootApplication
  @EnableDiscoveryClient
  public class ZuulApp {
      public static void main(String[] args) {
          SpringApplication.run(ZuulApp.class, args);
      }
  }
  ```

+ 配置

  first：自定义路由条目的名称

  ```yaml
  zuul:
    ignoredServices: '*'   #配置此句后，zuul将不会使用serviceId作为路由路径，只能通过下面的path
    routes:
      first:
        serviceId: cloud-video  #Application 应用名称（非实例名称）
        path: /my/**	#对应的访问路径
  ```

+ 在启动类上注解 **@EnableZuulProxy**





## spring security

### 基于表单的认证

####  配置类

+ 继承WebSecurityConfigurerAdapter
+ 重写configure(HttpSecurity http)方法

~~~ java
@Configuration
public class ItbSecurityConfig extends WebSecurityConfigurerAdapter {
    @Bean
    public PasswordEncoder passwordEncoder(){
        //此处使用了spring security的BCryptPasswordEncoder加盐加密方式。
        //如需其他加密方式，如md5等，可以在此方法内实现。
        return new BCryptPasswordEncoder();
    }
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .csrf().disable()//TODO 关闭csrf不妥
                .httpBasic()
                .and().authorizeRequests()//以下是授权的相关配置
                .antMatchers("/itb/user/register").permitAll()//此请求不需要身份认证
                .anyRequest()//任何请求
                .authenticated();//都需要身份认证
    }
}
~~~

#### 自定义认证逻辑

+ 实现UserDetailsService接口

  校对从前端收到user数据，与数据库中的用户名密码做比对.

  可以自己实现UserDetails接口，在自定义的实现类里写好校验逻辑，例如：判断用户是否被冻结、密码是否过期等等

  + 注意UserDetails实体类对象中的密码必须为密文，否则spring security会报异常：java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null"
  + SpringBoot2.0抛弃了原来的NoOpPasswordEncoder，要求用户保存的密码必须要使用加密算法后存储，在登录验证的时候Security会将获得的密码在进行编码后再和数据库中加密后的密码进行对比
  + 参考：<https://blog.csdn.net/SWPU_Lipan/article/details/80586054>

  ```java
  @Component
  public class ItbUserDetailsService implements UserDetailsService {
      @Autowired
      private UserMapper userMapper;
  
      @Override
      public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
          //从数据库中查出对应username的用户信息
          UserExample userExample = new UserExample();
          userExample.createCriteria().andNameEqualTo(username);
          List<User> result = userMapper.selectByExample(userExample);
          //查询结果唯一，并组装成UserDetails的实现类对象
          if (result.size() == 1){
              User userDb = result.get(0);
              return new org.springframework.security.core.userdetails.User(
                              username,
                              userDb.getPassword(),
                  AuthorityUtils.commaSeparatedStringToAuthorityList(userDb.getGroupName()));
          }else {
              throw new UsernameNotFoundException("用户名不存在");
          }
      }
  }
  ```

  

#### 密码的加密解密

+ 在配置类中加入PasswordEncoder方法实现，加密方式在该实现内定义。
+ 通过@Autowired注解注入PasswordEncoder对象，接着就可以使用该对象进行加密解密。
+ 具体代码见  3.1.1配置类  中的示例代码。

####  关于csrf

参考：<https://blog.csdn.net/sinat_28454173/article/details/52251004>

暂时只知道不关闭csrf的话（关闭方法.csrf().disable()），会导致：

+ 跨域访问时.antMatchers的配置不生效。

+ 即使登录成功(由于post被拦截，其实无法提交登录表单，即无法登录成功)，也只有get请求能正常访问。post、put、delete等依然会403错误

  + 官网给出的解决方案：发送post等请求时带上CSRF的token

  + ~~~json
    username: user
    password: f0518e7f-05bd-4293-9bd9-70a488184ae0
    _csrf: 29a3f518-38f4-411f-9fd0-63f68387cc09
    ~~~

  + ![1570093007453](imgs\1570093007453.png)

#### 个性化认证流程

##### 自定义登录页面

+ 修改loginPege的配置

+ 修改loginProcessingUrl   配置登录表单提交的路径

+ 修改antMatchers  将自定义的登录页面设为不用身份认证

+ 示例代码：

  这里将loginPage设为/unAuthHandle，指跳转到处理该路径的controller，具体行为由该controller处理。

  ~~~java
  @Override
      protected void configure(HttpSecurity http) throws Exception {
          //super.configure(http);
          http
                  .csrf().disable()//TODO 暂时关闭csrf
                  .formLogin()
                  .loginPage("/unAuthHandle")
                  .loginProcessingUrl("/login/form")
                  .and().authorizeRequests()
                  .antMatchers(securityProperties.getForm().getLoginPage(),
                          "/unAuthHandle").permitAll()
                  .anyRequest()
                  .authenticated();
      }
  ~~~

  

##### 自定义登录结果处理

+ 登录成功处理

  + 实现AuthenticationSuccessHandler接口，并设为spring组件。

  + 重写onAuthenticationSuccess方法。在方法内根据业务需求进行处理。

    ~~~java
    @Component("itbAuthenticationSuccessHandler")
    public class ItbAuthenticationSuccessHandler implements AuthenticationSuccessHandler {
    
        private final Logger log = LoggerFactory.getLogger(getClass());
    
        /**
         * 工具。对象转为json
         * 该实例由spring启动时自动创建，此处只要注入即可使用
         */
        @Autowired
        private ObjectMapper objectMapper;
       
        @Override
        public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                            Authentication authentication) throws IOException, ServletException {
            log.info("[***itb***]用户登录成功");
            response.setContentType("application/json;charset=UTF-8");
            response.getWriter().print(objectMapper.writeValueAsString(authentication));
    
        }
    }
    ~~~

  + 修改配置类。successHandler

    ~~~java
    @Configuration
    public class FormSecurityConfig extends WebSecurityConfigurerAdapter {
        @Autowired
        private AuthenticationSuccessHandler itbAuthenticationSuccessHandler;
    
        @Autowired
        private AuthenticationFailureHandler itbAuthenticationFailureHandler;
    
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            //super.configure(http);
            http
                    .csrf().disable()//TODO 暂时关闭csrf
                    .formLogin()
                    .loginPage("/unAuthHandle")
                    .loginProcessingUrl("/login/form")
                    .successHandler(itbAuthenticationSuccessHandler)//***
                    .failureHandler(itbAuthenticationFailureHandler)//***
                    .and().authorizeRequests()
                    .antMatchers(securityProperties.getForm().getLoginPage(),
                            "/unAuthHandle").permitAll()
                    .anyRequest()
                    .authenticated();
        }
    }
    ~~~

    

+ 登录失败处理

  + 与成功处理类似。实现AuthenticationFailureHandler接口

### OAuth2认证

#### QQ登录

![1569478761701](imgs\1569478761701.png)

+ 编写QQ Api 接口。获取qq的用户信息getUerInfo()

+ 实现QQ api的接口，继承AbstractOAuth2ApiBinding。定义获取用户信息的方法。依据是qq互联官网提供的接口

+ 继承AbstractOAuth2ServiceProvider<QQ Api>

+ 实现ApiAdapter<QQ Api>

+ 继承OAuth2ConnectionFactory<QQ Api>

+ 目前为止已经获取到qq用户的信息。开始存入数据库。

+ 继承SocialConfigurerAdapter，编写social配置类。

+ 手动建立数据库UserConnect表

+ 接下来整合到spring Security里。实现SocialUserDetailsService接口

+ 把上面过程中缺少的配置参数补充完整。providerId、appId、clientSecret

+ 向SecurityConfig添加social过滤器。social过滤器默认拦截的是“/auth”

  

### 官方文档

#### SecurityContextHolder

+ SecurityContextHolder里的Authentication存储了当前已登录用户的详细信息

+ 可以在应用程序中的任何位置使用以下代码块来获取当前经过身份验证的用户的信息

  ~~~java
  Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
  
  if (principal instanceof UserDetails) {
  String username = ((UserDetails)principal).getUsername();
  } else {
  String username = principal.toString();
  }
  ~~~

  UserDetails实例即用户的具体信息。

+ 可以编写自己的过滤器或MVC控制器，实现不基于Spring Security身份验证系统的过滤器，做法如下：

  编写一个过滤器（或等效过滤器），该过滤器从某个位置读取第三方用户信息，构建特定于Spring Security的`Authentication`对象，然后将其放入`SecurityContextHolder`

#### UserDetailsService

+ 此接口上的唯一方法接受一个`String`基于用户名的参数，并返回`UserDetails`
+ UserDetailsService中返回的UserDetails将用于后续的比对校验

+ 此接口只是根据username获取到数据库中的用户信息  并封装到UserDetails中。
+ 它不负责身份认证，身份认证由AuthenticationManager进行。如若需要自定义认证过程，使用AuthenticationProvider

## spring boot

### 快速搭建

+ 依赖

  ~~~xml
  		<parent>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-parent</artifactId>
          <version>2.1.1.RELEASE</version>
      </parent>
  
      <dependencies>
          <dependency>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-web</artifactId>
          </dependency>
      </dependencies>
  ~~~

+ 创建启动类，添加注解@SpringBootApplication

+ ```java
  @SpringBootApplication
  public class XxxApp {
      public static void main(String[] args) {
          SpringApplication.run(XxxApp.class, args);
      }
  }
  ```

### cors 允许跨域访问

参考：http://www.spring4all.com/article/177

大致分为全局配置和局部配置。

- 方式1：返回新的CorsFilter

  ~~~java
  package com.hehe.yyweb.config;
  
  @Configuration
  public class GlobalCorsConfig {
      @Bean
      public CorsFilter corsFilter() {
          //1.添加CORS配置信息
          CorsConfiguration config = new CorsConfiguration();
            //放行哪些原始域
            config.addAllowedOrigin("*");
            //是否发送Cookie信息
            config.setAllowCredentials(true);
            //放行哪些原始域(请求方式)
            config.addAllowedMethod("*");
            //放行哪些原始域(头部信息)
            config.addAllowedHeader("*");
            //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）
            config.addExposedHeader("*");
  
          //2.添加映射路径
          UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource();
          configSource.registerCorsConfiguration("/**", config);
  
          //3.返回新的CorsFilter.
          return new CorsFilter(configSource);
      }
  }
  ~~~

  

- 方式2：重写WebMvcConfigurer

  ~~~java
  package com.hehe.yyweb.config;
  
  @Configuration
  public class GlobalCorsConfig {
      @Bean
      public WebMvcConfigurer corsConfigurer() {
          return new WebMvcConfigurer() {
              @Override
              //重写父类提供的跨域请求处理的接口
              public void addCorsMappings(CorsRegistry registry) {
                  //添加映射路径
                  registry.addMapping("/**")
                          //放行哪些原始域
                          .allowedOrigins("*")
                          //是否发送Cookie信息
                          .allowCredentials(true)
                          //放行哪些原始域(请求方式)
                          .allowedMethods("GET","POST", "PUT", "DELETE")
                          //放行哪些原始域(头部信息)
                          .allowedHeaders("*")
                          //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）
                          .exposedHeaders("Header1", "Header2");
              }
          };
      }
  }
  ~~~

  

- 方式3：使用注解（[@CrossOrigin](https://github.com/CrossOrigin)）

  示例     @CrossOrigin("http://localhost:8080") 

### restful通常的请求风格

- GET /User/
- GET /User/3
- POST /User
- PUT /User/1
- DELETE /User/1

### PathVariable数据校验时失效

```java
@GetMapping("/{id}")
  public Video getVideoById(
          @PathVariable @Valid
          @Min(value = 10000,message = "视频id不能小于10000")
          @Max(value = 19999,message = "视频id不能大于19999")
          @NotNull(message = "视频id不能为空") Integer id){
    return videoService.getVideoById(id);
  }
```

PathVariable注解能够获取url路径上的参数。

在controller层对方法参数进行数据校验时，如果参数是通过注解PathVariable进行获取，这时对该入参进行数据校验，当校验错误时**不会抛出异常**。

解决办法：对PathVariable获取的参数进行数据校验，应该在注解GetMapping的括号内用正则表达式进行约束。示例如下：

```java
@GetMapping("/path/{group:[a-zA-Z0-9_]+}/{userid}")
@ResponseBody
public String path(@PathVariable("group") String group,
                   @PathVariable("userid") Integer userid) {
    return group + ":" + userid;
}
```

默认情况下，上述的正则表达式匹配失败时，会抛出org.springframework.web.HttpRequestMethodNotSupportedException：Request method 'GET' not supported

参考：

![1567482264349](C:\Users\vgeg\AppData\Roaming\Typora\typora-user-images\1567482264349.png)

### DTO转化为BO

参考链接：<https://blog.csdn.net/lw7551/article/details/62426579>

核心是使用了org.springframework.beans.BeanUtils#copyProperties方法。

+ 创建公共的转换接口DtoConvert；
+ 在DTO类中用内部类实现上述接口；
+ 在DTO类中创建公开的转换方法，方法实现利用了上述内部类；
+ 如若需要可定义逆向转化；



# idea

## 设置

### 自动提示方法的传入参数

File-Settings-Editor-General-Code Completion

![5243f839533](imgs\5243f839533.jpg)

### maven设置下载doc

参考：<https://blog.csdn.net/u014653854/article/details/80700408>

![1568981824413](imgs\1568981824413.png)

![20180615081422436](imgs\20180615081422436.png)

### 关闭单行自动折叠

![1568959916584](imgs\1568959916584.png)

### 鼠标缩放字体大小

![1567818507644](imgs\1567818507644.png)

如上图所示。“Decrease Font Size”和“Increase Font Size”分别是增大和缩小。

## 快捷键

### 查找关键字

+ Ctrl+N：类查找
+ Ctrl+Shift+R：全局关键字查找

### 查看类关系

+ 向下查看：Ctrl+Alt+B
+ 向上查看：鼠标右键+diagrams+show...
+ 类关系：ctrl+H

### 格式化代码

+ Ctrl+Alt+L

## 模板

+ sout：System.out.println();

+ .var：可以补全函数返回值。

+ fori : 循环遍历。

  + iter ：增强遍历

    ```java
    ArrayList<Integer> arrayList = new ArrayList<>();
    for (Integer integer : arrayList) {
        
    }
    ```

  + list.for : 列表遍历，效果类似上条。

+ xxx.null : if判断为空。
  
+ xxx.nn : if判断非空。
  
+ prsf ：私有静态常量
  
  + psf : 共有静态常量

+ 自定义模板：

## maven

### 基础命令

+ mvn clean  : 清除编译信息。会删除target目录
+ mvn compile  : 编译main下的代码
+ mvn test  : 会编译main和test下的代码
+ mvn package  : 编译并打包
+ mvn install  : 编译、打包、发送到本地仓库 

### 概念模型

![1569659094361](imgs\1569659094361.png)









# java

## List容器遍历方式

~~~java
public class Main {
  public static void main(String[] args) {
    List<String> list =  Arrays.asList("matt","john","gary");
       
    // 使用for loop
    for(int i = 0 ; i < list.size() ; i++ ) {
      System.out.println(list.get(i));
    }
    
    // 使用for-each loop
    for(String s : list) {
      System.out.println(s);
    }
    
    // 使用Java 8 forEach()
    list.forEach(new Consumer<String>() {
      @Override
      public void accept(String s) {
        System.out.println(s);
      }
    });
    
    // 使用Java 8 forEach() 搭配 Lambda語法
    list.forEach(s -> System.out.println(s));

    // 使用Java 8 forEach() 搭配 Lambda 及 Method References語法
    list.forEach(System.out::println);
  }
}
~~~



## Conllection类的使用

//TODO:

## 项目和工具

### PageHelper

项目地址：<https://github.com/pagehelper/Mybatis-PageHelper>

+ 简单使用

  + 引入依赖

    ~~~xml
    <dependency>
        <groupId>com.github.pagehelper</groupId>
        <artifactId>pagehelper</artifactId>
        <version>latest version</version>
    </dependency>
    ~~~

    

  + 简单配置

    配置参数说明：https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md

  ~~~yaml
  pagehelper:
    #helperDialect: mariadb
    reasonable: true
    supportMethodsArguments: true
  ~~~

  + 开始使用

    参考：[https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#3-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8](https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#3-如何在代码中使用)

    ~~~java
    //第二种，Mapper接口方式的调用，推荐这种使用方式。
    PageHelper.startPage(1, 10);
    List<Country> list = countryMapper.selectIf(1);
    
    //第三种，Mapper接口方式的调用，推荐这种使用方式。
    PageHelper.offsetPage(1, 10);
    List<Country> list = countryMapper.selectIf(1);
    
    ~~~

    

### swagger

+ 引入依赖

  ~~~xml
  <!-- swagger part 1: springfox-swagger2 -->
          <dependency>
              <groupId>io.springfox</groupId>
              <artifactId>springfox-swagger2</artifactId>
              <version>2.9.2</version>
          </dependency>
          <!-- swagger part 2: springfox-swagger-ui -->
          <dependency>
              <groupId>io.springfox</groupId>
              <artifactId>springfox-swagger-ui</artifactId>
              <version>2.9.2</version>
          </dependency>
  ~~~

+ 启动

  在springboot启动类上配置@EnableSwagger2注解

  ~~~java
  @SpringBootApplication
  @EnableSwagger2
  public class ItbApplication {
    public static void main(String[] args) {
      SpringApplication.run(ItbApplication.class,args);
    }
  }
  ~~~

  









# CSS

## 常用样式参数

### display属性

inline-block：让块级元素不自动换行（超出页面宽度除外）

```css
vertical-align: top;//把当前盒的top与行盒的top对齐
```

参考：<http://zh-tw.learnlayout.com/inline-block-layout.html>

### 关于居中

text-align: center;   -->在块级父容器中让行内元素水平居中

margin:0 auto;   -->当块级元素的with值已经指定时，该语句可以让块级元素水平居中

### display

none：隐藏对象。与[visibility](https://css.doyoe.com/properties/layout/visibility.htm)属性的`hidden`值不同，其不为被隐藏的对象保留其物理空间

inline：指定对象为内联元素。(缺省)

block：指定对象为块元素。

list-item：指定对象为列表项目。

inline-block：指定对象为内联块元素。（CSS2）

### height和line-height

+ height：指定**元素的高度**。表示整个元素的高度值。

缺省：auto，表示无特定高度值，取决于其它属性值

+ line-height：**行高**。指元素内，一行文本的高度值。

  通过指定该属性的值，可以起到修改**行距**大小的效果。

  参考：<https://blog.csdn.net/CodingAlarm/article/details/51916571>



# Typora

## 标题自动添加序号

打开文件 - 偏好设置 - 打开主题文件夹
随便复制一个css，改名为base.user.css，里面粘贴如下内容保存后重启Typora，输入标
题时会自动出现序号

```css
/** initialize css counter */
#write {
counter-reset: h1
}
h1 {
counter-reset: h2
}
h2 {
counter-reset: h3
}
h3 {
counter-reset: h4
}
h4 {
counter-reset: h5
}
h5 {
counter-reset: h6
}
/** put counter result into headings */
#write h1:before {
counter-increment: h1;
content: counter(h1) ". "
}
#write h2:before {
counter-increment: h2;
content: counter(h1) "." counter(h2) ". "
}
#write h3:before,
h3.md-focus.md-heading:before /** override the default style for focused headings */ {
counter-increment: h3;
content: counter(h1) "." counter(h2) "." counter(h3) ". "
}
#write h4:before,
h4.md-focus.md-heading:before {
counter-increment: h4;
content: counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) ". "
}
#write h5:before,
h5.md-focus.md-heading:before {
counter-increment: h5;
content: counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) ". "}
#write h6:before,
h6.md-focus.md-heading:before {
counter-increment: h6;
content: counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) "." counter(h6) ".
"}
/** override the default style for focused headings */
#write>h3.md-focus:before,
#write>h4.md-focus:before,
#write>h5.md-focus:before,
#write>h6.md-focus:before,
h3.md-focus:before,
h4.md-focus:before,
h5.md-focus:before,
h6.md-focus:before {
color: inherit;
border: inherit;
border-radius: inherit;
position: inherit;
left:initial;
float: none;
top:initial;
font-size: inherit;
padding-left: inherit;
padding-right: inherit;
vertical-align: inherit;
font-weight: inherit;
line-height: inherit;
}
————————————————
版权声明：本文为CSDN博主「Matrix-yang」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_21768483/article/details/84562095
```

参考：<https://blog.csdn.net/qq_21768483/article/details/84562095>

# JavaScript

ES6入门文档：<http://es6.ruanyifeng.com/>

## 基础

### 数据

#### 变量

+ var：尽量不用。

+ let：作用域是所在花括号内，即代码块内有效

+ const：只读常量。

  ​			作用域同let。

  

#### 数据类型

+ Object：对象。结构类似json。

+ Array：数组。

  数组遍历：[http://es6.ruanyifeng.com/#docs/array#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries%EF%BC%8Ckeys-%E5%92%8C-values](http://es6.ruanyifeng.com/#docs/array#数组实例的-entries，keys-和-values)

  ~~~javascript
  //两种声明方式
  let suzu_a = new Array();
  let suzu_b = [];
  
  //几种遍历方式
  //一、几乎不用
  for(let i = 0;i < suzu_b.length; i++){
      //TODO:...
  }
  //二、ES5时加入
  for(let i in suzu_b){
      //TODO:...
      console.log(suzu_b[i]);
  }
  //三、
  suzu_b.foreach(function(value){
      console.log(value);
      //TODO:...
  });
  //四、
  for(let value of suzu_b.values()){
      console.log(value);
      //TODO:...
  }
  
  ~~~

  

### 操作符

+ switch：

  ~~~javascript
  let name = 'naruto'
  switch(name){
      case 'naruto':
          console.log('naruto');
          break;
      case 'sakura':
          console.log('sakura');
          break;
      defult:
          console.log('defult');
  }
  ~~~

  

# Git

## 基础

+ 结构

  ![1569578396260](imgs\1569578396260.png)

+ 代码托管中心

  + push  clone  push  pull

  ![1569578589783](imgs\1569578589783.png)

  + fork

    ![1569578711225](imgs\1569578711225.png)



+ git add    初始化项目本地仓库

+ git config -global user.name xxx

  git config -global user.email xxx

  设置(全局)签名

+ git status 查看内容的状态。
+ git commit 提交到本地库



